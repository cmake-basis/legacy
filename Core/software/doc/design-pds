INTRODUCTION
============

  This document describes the project directory structure of SBIA projects. This
  structure is based on the Filesystem Hierarchy Standard of Linux distributions
  (http://www.linuxfoundation.org/en/FHS). The configuration of the installation
  was designed to account for the differences in UNIX-based systems and Windows
  as well as the installation of multiple versions of each package.



LEGEND
======

  In the following, <project> is a placeholder for the project name in lowercase letters only
  and <Project> is the case-sensitive project name. Further, <version> is a placeholder for
  the project version string "<major>.<minor>.<patch>", where <major> is the major version
  number, <minor> the minor version number, and <patch> the patch number.

  The root directory of a particular project source tree is denoted by <source>
  (c.f. CMake's PROJECT_SOURCE_DIR variable), while the root directory of the project's
  binary tree is referred to as <build> (c.f. CMake's PROJECT_BINARY_DIR variable).
  Note that each software development project consists of more than one project components
  (not identical to, but related with software package components). Each component can be
  downloaded, configured, build, and installed separately. See section Source Tree for details.
  The root directory of a development branch such as in particular the trunk
  (cf. section Repository Organization), is considered relative to the base URL of the
  project repository and denoted by <tag>, while the base URL is referred to as <url>.



REPOSITORY ORGANIZATION
=======================

  The URL of the project repository is "https://sbia-svn/projects/<Project>". The common
  top-level directories "trunk", "branches", and "tags" are located here.

  * "trunk/"                   The current development version of the project. Most development
                               is done in this master branch.

  * "branches/<name>/"         Separate branches named <name> are developed in subdirectories
                               under the "branches/" directory. One reason for branching is,
                               for example, to develop new features separate from the main
                               development branch, i.e., the trunk, and merging the desired
                               changes back to the trunk once the new feature is implemented
                               and stable, i.e., tested.

  * "branches/release/"        This branch is specifically used prior to releasing a new version
                               of the project.

                                  1. At the moment, when the software is about to be released,
                                     the "trunk/" is copied to "branches/release/". This branch
                                     is referred to as release candidate.

                                  2. Next the version information of the release candidate is
                                     updated such that it is assigned a unique version number.

                                     Note: The trunk is not associated with a version other
                                           than the revision number as the trunk is always
                                           considered to be in development.

                                  3. Then the testers are selected and informed to retrieve a copy of
                                     the software from "<url>/branches/release/". According to the
                                     testers feedback, the release candidate is bug fixed until all
                                     tests are passed.

                                  4. Once, the release candidate is stable, hence, passes all tests,
                                     a tag of the release candidate is made by copying
                                     "<url>/branches/release/" to "<url>/tags/<Project>-<version>/".

                                  5. Finally, the bug fixes applied to the release candidate are merged
                                     back to the "trunk" and the release candidate, i.e., the branch
                                     "branches/release/", is deleted.

  * "tags/<Project>-<version>/"   Tagged release version of the project. The reason for including the
                                  project name in the name of the tagged branch is, that revision
                                  control systems often use the last URL part as name for the directory
                                  to which the URL's content is checked out or exported if no name
                                  for this directory is specified explicitly. In case of SVN, the
                                  following command will export the released software to a new
                                  directory under the current working directory named
                                  "<Project>-<version>".

                                    svn export <url>/tags/<Project>-<version>

  Under the "trunk/" and the release branches, a version of the entire source tree can be found.
  Other branches under "branches/<name>/" may only contain a subset of the trunk such as,
  for example, only the software component (see Source Tree).



SOURCE TREE
===========

  As the example data and the testing tree are not required in order to build and install the
  software, all files related to the software component of a project are separated from the
  example and testing component. This allows an SVN check-out/export of the software component
  alone. Moreover, each project has a so-called "ALL" component which by itself only consists
  of CMake files (if not only one CMakeLists.txt file) which manage the download, configuration,
  build and installation the software, example, and testing component only if desired by the user.
  This can be compared to the concept of Online Installers which download the actual required
  packages on demand. The user downloads at first only a lightweight installer executable.
  Similarly, in case of an SBIA software development project, the user (both members of the
  lab and external users) at first retrieve a copy of the ALL component. During the configure
  step of CMake, the user decides whether the software, example, and testing component should
  be build. During the build of the ALL component, only the selected components are downloaded,
  configured, and build. Accordingly, on installation, only the built components are installed.

  It is important to note the difference between unit tests and system tests. Most often, only
  system tests will be performed due to the research character of the projects. These tests
  are usually implemented in a scripting language such as BASH or Python. They simply call the
  built executables with different test input data and compare the output to the expected
  results. System tests can also be performed using the installed software. Unit tests,
  on the other side, are not supposed to be installed (and may not even be distributed to
  reduce the size of the packages). Unit tests test only single modules such as a C++ class.
  The size of the additional data required for unit tests shall be small. Entire medical image
  data sets are mostly only required for system tests.


  Directories
  -----------

  PROJECT_SOURCE_DIR    := PROJECT_BUNDLE_DIR | PROJECT_SOFTWARE_DIR | PROJECT_EXAMPLE_DIR | PROJECT_TESTING_DIR

  PROJECT_BUNDLE_DIR    := <tag>/bundle/
  PROJECT_SOFTWARE_DIR  := <tag>/software/
  PROJECT_EXAMPLE_DIR   := <tag>/example/
  PROJECT_TESTING_DIR   := <tag>/testing/

  SOFTWARE_CONFIG_DIR   := <tag>/software/config/
  SOFTWARE_SRC_DIR      := <tag>/software/src/
  SOFTWARE_DATA_DIR     := <tag>/software/data/
  SOFTWARE_DOC_DIR      := <tag>/software/doc/
  SOFTWARE_TESTS_DIR    := <tag>/software/tests/

  TESTING_DATA_DIR      := <tag>/testing/data
  TESTING_EXPECTED_DIR  := <tag>/testing/expected
  TESTING_TESTS_DIR     := <tag>/testing/tests


  Content
  -------

  * Software

    - CMakeLists.txt   Root CMakeLists.txt file of software component.
    - AUTHORS          Lists names of authors.
    - LICENSE          Copyright and license notices.
    - README           Root documentation file (simply referred to as README file).
    - INSTALL          Build and installation instructions.

    - SOFTWARE_CONFIG_DIR                       Software configuration, i.e., CMake configuration files.
    - SOFTWARE_SRC_DIR                          All source code files.
    - SOFTWARE_DATA_DIR                         Auxiliary data such as medical atlases and pre-computed lookup tables.
    - SOFTWARE_DOC_DIR                          Documentation files.
    - SOFTWARE_TESTS_DIR                        Implementation of unit tests and required test data.
    - SOFTWARE_TESTS_DIR/CTestConfig.cmake      CTest configuration file (for submission of unit test results to CDash).
    - SOFTWARE_TESTS_DIR/CTestCustom.cmake.in   Custom CTest configurations (of unit tests).

  * Example

    - CMakeLists.txt   Root CMakeLists.txt file of example component.
    - (.*)             Files required for example application of software.

  * Testing

    - CMakeLists.txt         Root CMakeLists.txt file of testing component.
    - CTestConfig.cmake      CTest configuration file (for submission of system test results to CDash).
    - CTestCustom.cmake.in   Custom CTest configurations (of system tests).
    - TESTING_DATA_DIR       Data used by system tests as input to the software.
    - TESTING_EXPECTED_DIR   Testing baseline data, e.g., PNG images of middle slice which
                             is compared to same slice of test output.
    - TESTING_TESTS_DIR      Implementations of system tests.

  * Bundle

    The bundle is the collection of ALL other components. The software component is the basis and
    all other components are downloaded/extracted/copied to a subdirectory of the software component.
    Hence, the bundle will always contain at least the software component, which is not optional.
    The root CMakeLists.txt file of the software component is implemented in such way that it
    traverses in these subdirectories if they exist.

    - CMakeLists.txt   Manages the download and proper assembly of the selected bundle components,
                       and triggers the configuration, build, and installation of these components.



BUILD TREE
==========


  Bundle
  ------

  On "make"

  * Download PROJECT_SOFTWARE_DIR to "<build>/bundle/"
  * If selected, download PROJECT_EXAMPLE_DIR to "<build>/bundle/example/"
  * If selected, download PROJECT_TESTING_DIR to "<build>/bundle/testing/"
  * Configure and build bundle with CMake source directory "<build>/bundle/" and
    binary directory "<build>/bundle-build/"


  Software
  --------

  * Directories

    - RUNTIME_OUTPUT_DIRECTORY := "<build>/bin/"
    - LIBRARY_OUTPUT_DIRECTORY := "<build>/lib/" (UNIX) | "<build>/bin" (Windows)
    - ARCHIVE_OUTPUT_DIRECTORY := "<build>/lib/"

  * Content

    - RUNTIME_OUTPUT_DIRECTORY   All executables.
    - LIBRARY_OUTPUT_DIRECTORY   Shared libraries.
    - ARCHIVE_OUTPUT_DIRECTORY   Static libraries and import libraries (Windows).


  Example
  -------

  By default, nothing to do as the example files just need to be copied to some
  directory. These files are mainly just used as input to the programs without
  the need to configure or build them. The implementation of exceptions is up
  to the project developer.


  Testing
  -------



INSTALL TREE
============


  Options
  -------

  INSTALL_PREFIX : Installation directories prefix (<prefix>).
                   Defaults to "/usr/local" on UNIX-based systems
                   and "C:\Program Files\SBIA" on Windows.

  INSTALL_SINFIX : Installation directories suffix or infix, respectively (<sinfix>).
                   Defaults to "sbia/\${PROJECT_NAME_LOWER}" on UNIX-based systems
                   and an empty string on Windows.


  Advanced options
  ----------------

  INSTALL_BIN_DIR     = "<prefix>/bin/<sinfix>/"
  INSTALL_LIB_DIR     = "<prefix>/lib/<sinfix>/"
  INSTALL_INCLUDE_DIR = "<prefix>/include/<sinfix>/sbia/<project>/"
  INSTALL_DOC_DIR     = "<prefix>/share/<sinfix>/doc/"
  INSTALL_DATA_DIR    = "<prefix>/share/<sinfix>/data/"
  INSTALL_EXAMPLE_DIR = "<prefix>/share/<sinfix>/example/"
  INSTALL_MAN_DIR     = "<prefix>/share/<sinfix>/man/"


  Content
  -------

  INSTALL_BIN_DIR     - Main executables only

  INSTALL_LIB_DIR     - Static and shared libraries
                      - Utility executables which are called by other executables only
                      - <Project>Config.cmake
                      - <Project>ConfigVersion.cmake

  INSTALL_INCLUDE_DIR - Public header files of static and shared libraries

  INSTALL_DOC_DIR     - README            : Root documentation file. Links to other documents
                      - AUTHORS           : List of authors of the software project
                      - LICENSE           : Copyright and license information
                      - ChangeLog         : Generated from SVN history
                      - User Manual       : Guides user through example application
                      - Developer Manual  : Describes implementation details
                      - API documentation : Generated from source code, e.g.,
                                            using Doxygen, Epydoc, Sphinx,â€¦

  INSTALL_MAN_DIR     - Man pages of main executables in subfolder "man1"
                      - Man pages of libraries in subfolder "man3"

  INSTALL_DATA_DIR    - Auxiliary data such as image atlases and pre-computed lookup tables

  INSTALL_EXAMPLE_DIR - All data required to follow example as described in User Manual


  Symbolic links
  --------------

  On UNIX-based systems, optionally create the following symbolic links (when <sinfix> is given).
  Note that the link creation will fail if a file or directory with the links name already exists.
  This is desired and will simply be reported to the user. The projects files are yet
  installed already in the specified installation directories.

  * If INSTALL_BIN_DIR != "<prefix>/bin" create symbolic links
    "<prefix>/bin/<exec>" -> "INSTALL_BIN_DIR/<exec>"

  * If INSTALL_MAN_DIR != "<prefix>/share/man" create symbolic links
    "<prefix>/share/man/man?/<name>.?" -> "INSTALL_MAN_DIR/man?/<name>.?"

  * If INSTALL_DOC_DIR != "<prefix>/share/doc/<sinfix>" create symbolic link
    "<prefix>/share/doc/<sinfix>" to "INSTALL_DOC_DIR"


  Components
  ----------

  For the packaging and installation of a software project, the following package components and
  component groups are distinguished.

  * Runtime                Executables and shared libraries required to run the software.

  * Development            Static and shared libraries which can be used to implement software
                           that builds upon these libraries.

  * Documentation

    - User Manual          Introduces software for the end-user and demonstrates its usage on
                           one or more provided examples.
    - Developer Manual     Describes implementation details.
    - API Documentation    Documents API of libraries.

  * Examples

    - Runtime              All example files required to follow the steps in the User Manual.
    - Development          Example implementations which make use of the provided libraries.

  * Testing                System tests which can be used to test the correct function and/or
                           installation of the Runtime component. Note that unit tests are
                           not included as these are not supposed to be packaged at all.



CALLING CONVENTIONS
===================

  Note: These calling conventions should be hidden to the developer by automatically generating
        utility functions for each supported programming language.

  Main executables in <prefix>/bin call utility executables relative to their own installation directory.
  For example, a BASH script called main.sh that executes a utility script util.sh in <prefix>/lib/sbia/<project>
  would do so such as

    bindir=`cd \`dirname $0\`; pwd`
    libdir=$bindir/@LIB_DIR@

    # call utility executable in libexec directory
    $libdir/util

  where @LIB_DIR@ is

    file (RELATIVE_PATH DIR "${INSTALL_BIN_DIR}" "${INSTALL_PREFIX}")
    file (RELATIVE_PATH LIB_DIR "${INSTALL_PREFIX}" "${INSTALL_LIB_DIR}")
    set (LIB_DIR "${DIR}/${LIB_DIR}")

  If an executable in the 'bin' directory wants to execute another executable in the same directory,
  it simply does it as follows:

    # call other main executable
    $bindir/othermain
